<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on ycwang&#39;s Blog</title>
    <link>https://www.ycwang.me/blog/</link>
    <description>Recent content in Blogs on ycwang&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright © 2020–2021, ycwang all rights reserved.</copyright>
    <lastBuildDate>Mon, 14 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://www.ycwang.me/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python Import Hook 原理</title>
      <link>https://www.ycwang.me/blog/python-import-hook-%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 14 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.ycwang.me/blog/python-import-hook-%E5%8E%9F%E7%90%86/</guid>
      <description>Python import 过程中，可以通过添加钩子，修改文件查找和加载的方式。游戏开发中，通常需要将脚本文件打包和加密，这时就要用到 Python import hook 机制。下面分别阐述 Python3 和 Python2 的 import hook 工作流程。
Python3 官方文档 Python3 The Import System 提供了最详细的说明。
模块查找 工作流程跟 Python2 不同，废除了 find_module 和 load_module，代之为 find_spec，create_module 和 exec_module。模块查找过程为：
 先从 sys.modules 里面找 其次通过 meta hooks 机制来加载模块，这是注册到 sys.meta_path 列表的对象，它拥有最高优先级，设置可以通过它替换 built-in module 然后从 sys.path 路径列表找模块，其中每个 path 会经由 import path hooks 来处理，这是注册到 sys.path_hooks 列表的对象，用以修改查找路径  Meta Hook 工作流程 分为2个部分：Finder 和 Loader
 调用 Finder.find_spec 获得 Spec 对象，其中 Spec.loader 为自定义的 Loader 对象 调用 Loader.</description>
    </item>
    
    <item>
      <title>PCH 问题总结</title>
      <link>https://www.ycwang.me/blog/pch-%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://www.ycwang.me/blog/pch-%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <description>MSVC 下可能遇到的 PCH 错误
 fatal error C3859: virtual memory range for PCH exceeded; please recompile with a command line option of ‘-ZmXXX’ or greater fatal error C1076: compiler limit: internal heap reached; use /Zm to specify a higher limit fatal error C1083: Cannot open include file: ‘xyzzy’: No such file or directory  MSVC 会开多进程编译，每个 cl 进程都会加载 PCH，如果 PCH 较大且进程很多，就会爆内存或虚存。编译选项 /MP 用来指定并行 cl 的数量，默认值为机器的核心数量。例如：/MP32 开32个 cl 进程并行编译，如果 PCH 为 250MB，那么可能同时触发 32 次 VirtualAlloc() ，请求 32 * 250 MB = 8000 MB 的内存请求，把虚存爆掉（fatal error C3857）。</description>
    </item>
    
    <item>
      <title>Visual Studio C&#43;&#43; 文件编码</title>
      <link>https://www.ycwang.me/blog/visual-studio-c&#43;&#43;-%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81/</link>
      <pubDate>Sun, 13 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.ycwang.me/blog/visual-studio-c&#43;&#43;-%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81/</guid>
      <description>编译器处理源文件字符编码时，分为 source charset 和 execution charset
 source charset: 源文件的字符编码 execution charset：代码中的字符串以何种编码写到 binary  Microsoft C/C++ 编译器按以下的方式处理：
 所有源文件，内部会先转换为 UTF-8 再进行编译 如果有 BOM，则根据 BOM 来决定如何进行转换 如果无 BOM，则根据前8个字符来判断是否为 UTF-16 及 endian 如果无 BOM，也不是 UTF-16，则当作本地编码处理 编译时，会根据 execution charset 的设置，将代码中的字符串从 UTF-8 转换到目标编码  VS2015 Update 2 之后新添加了两个编译选项：
 /source-charset:&amp;lt;iana-name&amp;gt;|.NNNN /execution-charset:&amp;lt;iana-name&amp;gt;|.NNNN  分别用来指定 source charset 和 execution charset
此外还有个简化的指令 /utf-8 等介于同时使用 /source-charset:utf-8 和 /execution-charset:utf-8
综上，对于带中文注释的源码，最佳解决方案是：
 全部源文件使用 UTF-8 编码 编译指令加上 ```/utf-8`` 并开启 /validate-charset 确保源码没有包含非法字符。当使用了上述 charset 选项之后，默认会开启这个检查，除非被显示关闭 /validate-charset-   参考资料：</description>
    </item>
    
  </channel>
</rss>
